
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pisces.models.grids.base &#8212; Pisces  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pisces/models/grids/base';</script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Pisces  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../reference/index.html">
    Pisces User Guide
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../reference/index.html">
    Pisces User Guide
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pisces.models.grids.base</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pisces.models.grids.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Base class grid managers for Pisces.</span>

<span class="sd">This module provides the core classes and logic for defining, storing, and manipulating</span>
<span class="sd">the structured grids that underlie Pisces models.</span>

<span class="sd">For details on the use of this module, consult :ref:`model_grid_management`.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">unyt</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RegularGridInterpolator</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">pisces.geometry</span> <span class="kn">import</span> <span class="n">GeometryHandler</span>
<span class="kn">from</span> <span class="nn">pisces.geometry.coordinate_systems</span> <span class="kn">import</span> <span class="n">CoordinateSystem</span>
<span class="kn">from</span> <span class="nn">pisces.io</span> <span class="kn">import</span> <span class="n">HDF5_File_Handle</span><span class="p">,</span> <span class="n">HDF5ElementCache</span>
<span class="kn">from</span> <span class="nn">pisces.models.grids.structs</span> <span class="kn">import</span> <span class="n">BoundingBox</span><span class="p">,</span> <span class="n">ChunkIndex</span><span class="p">,</span> <span class="n">DomainDimensions</span>
<span class="kn">from</span> <span class="nn">pisces.utilities.array_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CoordinateArray</span><span class="p">,</span>
    <span class="n">build_image_coordinate_array</span><span class="p">,</span>
    <span class="n">make_grid_fields_broadcastable</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pisces.utilities.config</span> <span class="kn">import</span> <span class="n">pisces_params</span>
<span class="kn">from</span> <span class="nn">pisces.utilities.containers</span> <span class="kn">import</span> <span class="n">LRUCacheDescriptor</span>
<span class="kn">from</span> <span class="nn">pisces.utilities.logging</span> <span class="kn">import</span> <span class="n">devlog</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pisces.geometry._typing</span> <span class="kn">import</span> <span class="n">AxisAlias</span>
    <span class="kn">from</span> <span class="nn">pisces.profiles.base</span> <span class="kn">import</span> <span class="n">Profile</span>

<span class="n">AxesSpecifier</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="s2">&quot;AxisAlias&quot;</span><span class="p">]</span>
<span class="n">AxesMask</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]</span>


<div class="viewcode-block" id="ModelGridManager">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.html#pisces.models.grids.base.ModelGridManager">[docs]</a>
<span class="k">class</span> <span class="nc">ModelGridManager</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manager class controlling the coordinate grid in Pisces models.</span>

<span class="sd">    The :py:class:`ModelGridManager` manages the underlying coordinate grid and</span>
<span class="sd">    component :py:class:`ModelField`-s of all Pisces :py:class:`~pisces.models.base.Model` instances.</span>

<span class="sd">    A :py:class:`ModelGridManager` provides the essential infrastructure to work with</span>
<span class="sd">    multi-dimensional data (fields) on a structured grid, including:</span>

<span class="sd">    - The bounding box (:py:attr:`BBOX`) describing the physical extent of each axis.</span>
<span class="sd">    - The grid shape (:py:attr:`GRID_SHAPE`) specifying how many cells exist along each axis.</span>
<span class="sd">    - Chunk shapes (:py:attr:`CHUNK_SHAPE`) for memory-efficient partial reads/writes.</span>
<span class="sd">    - A coordinate system (:py:attr:`coordinate_system`) to define axis names and transformations.</span>
<span class="sd">    - Mechanisms for chunked operations, coordinate generation, and new field creation.</span>

<span class="sd">    The manager internally references an HDF5 file at :py:attr:`path`. If the file does not exist,</span>
<span class="sd">    a new one is created (given sufficient parameters such as ``bbox`` and ``grid_shape``); if it does</span>
<span class="sd">    exist, a manager attempts to load its metadata from that file.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If you need to recreate a file from scratch (deleting an existing file), use ``overwrite=True``</span>
<span class="sd">       when instantiating. This permanently removes any prior data stored at that location.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ModelField : The individual data arrays stored in the manager.</span>
<span class="sd">    ModelFieldContainer : The container managing all fields in the HDF5 file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># @@ CLASS ATTRIBUTES @@ #</span>
    <span class="c1"># These flags / defaults can be set in subclasses to</span>
    <span class="c1"># refine the standard behavior of subclasses.</span>
    <span class="n">DEFAULT_LENGTH_UNIT</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kpc&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; str or unyt.Unit: The default length unit for this class.</span>

<span class="sd">    The default length unit can be overwritten / bypassed by providing the ``length_unit``</span>
<span class="sd">    argument when initializing this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DEFAULT_SCALE</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; str or list of str: The default scale for this class.</span>

<span class="sd">    Unless provided during class generation, the default scale determines the :py:attr:`scale` of the</span>
<span class="sd">    grid manager.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ALLOWED_COORDINATE_SYSTEMS</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; list of str: The names of the permitted coordinate systems for this manager class.</span>

<span class="sd">    If the class does not specify any coordinate systems here, then all coordinate systems are permitted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interpolator_cache</span><span class="p">:</span> <span class="n">LRUCacheDescriptor</span> <span class="o">=</span> <span class="n">LRUCacheDescriptor</span><span class="p">(</span>
        <span class="n">max_size</span><span class="o">=</span><span class="n">pisces_params</span><span class="p">[</span><span class="s2">&quot;system.cache.cache_sizes.grid_interpolator_cache_size&quot;</span><span class="p">]</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; :py:class:`~pisces.utilities.containers.LRUCacheDescriptor`: LRU cache for storing grid interpolators.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelGridManager.__init__">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.__init__.html#pisces.models.grids.base.ModelGridManager.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">coordinate_system</span><span class="p">:</span> <span class="n">CoordinateSystem</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bbox</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid_shape</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_shape</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a :py:class:`ModelGridManager` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : Union[str, Path]</span>
<span class="sd">            The path to the HDF5 file.</span>

<span class="sd">            If the path exists, then an attempt is made to load it as a manager; otherwise a new manager is initialized</span>
<span class="sd">            in a new file of the same name.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                If you want to overwrite an existing instance, you need to use ``overwrite=True``.</span>

<span class="sd">        coordinate_system : :py:class:`~pisces.geometry.base.CoordinateSystem`, optional</span>
<span class="sd">            The coordinate system that defines the dimensionality and axes of the grid.</span>

<span class="sd">            This is required when creating a new file (i.e., if the HDF5 file does not</span>
<span class="sd">            already exist). If you open an existing file, the coordinate system is loaded</span>
<span class="sd">            automatically from that file.</span>

<span class="sd">        bbox : NDArray[np.float64], optional</span>
<span class="sd">            The bounding box that defines the physical extent of the grid in each axis.</span>
<span class="sd">            Required if you are creating a new file. This should be convertible into a</span>
<span class="sd">            :py:class:`~pisces.models.grids.structs.BoundingBox`, with shape ``(2, NDIM)``,</span>
<span class="sd">            where ``NDIM`` matches the number of axes in ``coordinate_system``. The first row</span>
<span class="sd">            contains the minimum coordinate values along each axis, and the second row</span>
<span class="sd">            contains the maximum coordinate values.</span>

<span class="sd">            .. note::</span>

<span class="sd">               You can provide this in a Python list form such as ``[[x0_min, x0_max],</span>
<span class="sd">               [x1_min, x1_max], ...]``.</span>

<span class="sd">        grid_shape : NDArray[np.int64], optional</span>
<span class="sd">            The shape of the grid, specifying the number of cells along each axis.</span>
<span class="sd">            This is required for creating a new file. It should be a 1D array-like of</span>
<span class="sd">            integers with length equal to the number of dimensions in</span>
<span class="sd">            ``coordinate_system``.</span>
<span class="sd">        chunk_shape : NDArray[np.int64], optional</span>
<span class="sd">            The shape of each chunk used for subdividing the grid, allowing chunk-based</span>
<span class="sd">            operations or partial in-memory loading.</span>

<span class="sd">            If not provided, it defaults to</span>
<span class="sd">            ``grid_shape``, meaning the entire grid is treated as a single chunk. If specified,</span>
<span class="sd">            each element must divide the corresponding element in ``grid_shape`` without</span>
<span class="sd">            remainder.</span>

<span class="sd">            .. important::</span>

<span class="sd">                The choice to perform operations in chunks (or not to) is made by the developer of</span>
<span class="sd">                the relevant model. Generally, if it isn&#39;t necessary to perform operations in chunks, it&#39;s avoided.</span>
<span class="sd">                As such, it&#39;s generally advisable to leave this argument unchanged unless you have a clear reason</span>
<span class="sd">                to set it.</span>

<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If ``True``, an existing HDF5 file at ``path`` is removed before creating a new one.</span>
<span class="sd">            Defaults to ``False``. Note that this cannot overwrite an open or locked file.</span>

<span class="sd">        length_unit : str, optional</span>
<span class="sd">            The physical length unit for interpreting grid coordinates, for example `&quot;kpc&quot;`</span>
<span class="sd">            or `&quot;cm&quot;`. Defaults to :py:attr:`DEFAULT_LENGTH_UNIT`.</span>
<span class="sd">        scale : Union[List[str], str], optional</span>
<span class="sd">            The scaling mode for each axis, determining whether cells are spaced linearly or</span>
<span class="sd">            logarithmically. Each entry can be `&quot;linear&quot;` or `&quot;log&quot;`. If a single string is given,</span>
<span class="sd">            it is applied to all axes. Defaults to :py:attr:`DEFAULT_SCALE`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required parameters are missing when creating a new file or if dimensions are invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># SETUP path and manage the overwrite procedure.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="ow">and</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>

        <span class="c1"># MANAGE the setup of a new instance of one doesn&#39;t already exist.</span>
        <span class="c1">#   If the path exists, this is skipped, and we just load; otherwise, we</span>
        <span class="c1">#   attempt to generate a new instance using the skeleton builder.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="c1"># enforce required arguments.</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bbox</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">,</span> <span class="n">coordinate_system</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot create new ModelGridManager at </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> because not all &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of `bbox`, `grid_shape`, and `coordinate_system` were provided.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Build the skeleton</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">HDF5_File_Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_skeleton</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span>
                <span class="n">coordinate_system</span><span class="p">,</span>
                <span class="n">bbox</span><span class="p">,</span>
                <span class="n">grid_shape</span><span class="p">,</span>
                <span class="n">chunk_shape</span><span class="p">,</span>
                <span class="n">length_unit</span><span class="o">=</span><span class="n">length_unit</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Switch the handle so that we can read data as well.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">switch_mode</span><span class="p">(</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Open an existing file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">HDF5_File_Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>

        <span class="c1"># LOAD and compute attributes.</span>
        <span class="c1">#   These methods load the relevant attributes from the HDF5 file structure</span>
        <span class="c1">#   and then compute derived attributes from them on the fly. They can be</span>
        <span class="c1">#   safely reimplemented in subclasses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_attributes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_secondary_attributes</span><span class="p">()</span>

        <span class="c1"># Load fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_fields</span><span class="p">()</span></div>


    <span class="c1"># @@ LOADERS @@ #</span>
    <span class="c1"># These methods are all featured in the __init__ call as</span>
    <span class="c1"># modular methods to allow easy subclassing and keep things more</span>
    <span class="c1"># readable.</span>
    <span class="c1">#</span>
    <span class="c1"># There do frequently need to be altered in subclasses. Developers</span>
    <span class="c1"># should read through each of them and determine if changes need to be made.</span>
    <span class="k">def</span> <span class="nf">_load_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load grid attributes from the HDF5 file.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method loads bounding box, chunk shape, grid shape, scaling, and length unit from the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load the core attributes saved in the handle attributes.</span>

        <span class="c1">#: Docstring for bbox.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_BBOX</span><span class="p">:</span> <span class="n">BoundingBox</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;BBOX&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SHAPE</span> <span class="o">=</span> <span class="n">DomainDimensions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;CHUNK_SHAPE&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_GRID_SHAPE</span> <span class="o">=</span> <span class="n">DomainDimensions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;GRID_SHAPE&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;SCALE&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span><span class="p">:</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span> <span class="o">=</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LUNIT&quot;</span><span class="p">])</span>

        <span class="c1"># Load the coordinate system from the handle coordinates system group.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_system</span><span class="p">:</span> <span class="n">CoordinateSystem</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">[</span><span class="s2">&quot;CSYS&quot;</span><span class="p">],</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;hdf5&quot;</span>
        <span class="p">)</span>

        <span class="c1"># ensure that the coordinate system is a valid coordinate system.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_system</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Attempted to load invalid GridManager with coordinate system class </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_system</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> only supports </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the fields associated with the grid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Fields are managed using the `ModelFieldContainer` for easy access and manipulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="o">=</span> <span class="n">ModelFieldContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_secondary_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute attributes derived from grid metadata.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Computes scaled bounding box and log mask based on scaling.</span>
<span class="sd">        - Computes chunk size and cell size in scaled units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Manage scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ax</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BBOX</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_mask</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Compute chunk and cell sizes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_NCHUNKS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GRID_SHAPE</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NCHUNKS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_CELL_SIZE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span>

<div class="viewcode-block" id="ModelGridManager.build_skeleton">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.build_skeleton.html#pisces.models.grids.base.ModelGridManager.build_skeleton">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_skeleton</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">handle</span><span class="p">:</span> <span class="n">HDF5_File_Handle</span><span class="p">,</span>
        <span class="n">coordinate_system</span><span class="p">:</span> <span class="n">CoordinateSystem</span><span class="p">,</span>
        <span class="n">bbox</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span>
        <span class="n">grid_shape</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">],</span>
        <span class="n">chunk_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">length_unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HDF5_File_Handle</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a &quot;skeleton&quot; for the :py:class:`ModelGridManager` class.</span>

<span class="sd">        The skeleton is the base structure necessary to load an HDF5 file as this object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        handle: :py:class:`~pisces.io.HDF5_File_Handle`</span>
<span class="sd">            The HDF5 file handle at which to construct the skeleton.</span>

<span class="sd">        coordinate_system : :py:class:`~pisces.geometry.base.CoordinateSystem`, optional</span>
<span class="sd">            The coordinate system that defines the dimensionality and axes of the grid.</span>

<span class="sd">        bbox : NDArray[np.float64], optional</span>
<span class="sd">            The bounding box that defines the physical extent of the grid in each axis.</span>
<span class="sd">            This should be convertible into a :py:class:`~pisces.models.grids.structs.BoundingBox`,</span>
<span class="sd">            with shape ``(2, NDIM)``, where ``NDIM`` matches</span>
<span class="sd">            the number of axes in ``coordinate_system``. The first row</span>
<span class="sd">            contains the minimum coordinate values along each axis, and the second row</span>
<span class="sd">            contains the maximum coordinate values.</span>

<span class="sd">            .. note::</span>

<span class="sd">               You can provide this in a Python list form such as ``[[x0_min, x0_max],</span>
<span class="sd">               [x1_min, x1_max], ...]``.</span>

<span class="sd">        grid_shape : NDArray[np.int64], optional</span>
<span class="sd">            The shape of the grid, specifying the number of cells along each axis. It should be a 1D array-like of</span>
<span class="sd">            integers with length equal to the number of dimensions in</span>
<span class="sd">            ``coordinate_system``.</span>
<span class="sd">        chunk_shape : NDArray[np.int64], optional</span>
<span class="sd">            The shape of each chunk used for subdividing the grid, allowing chunk-based</span>
<span class="sd">            operations or partial in-memory loading.</span>

<span class="sd">            If not provided, it defaults to</span>
<span class="sd">            ``grid_shape``, meaning the entire grid is treated as a single chunk. If specified,</span>
<span class="sd">            each element must divide the corresponding element in ``grid_shape`` without</span>
<span class="sd">            remainder.</span>

<span class="sd">            .. important::</span>

<span class="sd">                The choice to perform operations in chunks (or not to) is made by the developer of</span>
<span class="sd">                the relevant model. Generally, if it isn&#39;t necessary to perform operations in chunks, it&#39;s avoided.</span>
<span class="sd">                As such, it&#39;s generally advisable to leave this argument unchanged unless you have a clear reason</span>
<span class="sd">                to set it.</span>

<span class="sd">        length_unit : str, optional</span>
<span class="sd">            The physical length unit for interpreting grid coordinates, for example `&quot;kpc&quot;`</span>
<span class="sd">            or `&quot;cm&quot;`. Defaults to :py:attr:`DEFAULT_LENGTH_UNIT`.</span>
<span class="sd">        scale : Union[List[str], str], optional</span>
<span class="sd">            The scaling mode for each axis, determining whether cells are spaced linearly or</span>
<span class="sd">            logarithmically. Each entry can be `&quot;linear&quot;` or `&quot;log&quot;`. If a single string is given,</span>
<span class="sd">            it is applied to all axes. Defaults to :py:attr:`DEFAULT_SCALE`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If required parameters are missing when creating a new file or if dimensions are invalid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform validation tasks. Ensure that the bounding box, grid_shape, chunk_shape, etc.</span>
        <span class="c1"># are correctly formatted and meet all the necessary standards.</span>
        <span class="c1">#</span>
        <span class="c1"># Validate the coordinate system.</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The allowed coordinate systems need to be checked.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">coordinate_system</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to build skeleton for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Input coordinate system was a </span><span class="si">{</span><span class="n">coordinate_system</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instance, but &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> only supports the following: </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">ALLOWED_COORDINATE_SYSTEMS</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="n">coordinates_ndim</span> <span class="o">=</span> <span class="n">coordinate_system</span><span class="o">.</span><span class="n">NDIM</span>
        <span class="n">bbox</span><span class="p">,</span> <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">bbox</span><span class="p">),</span> <span class="n">DomainDimensions</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chunk_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set the chunk shape to be the same as the grid shape.</span>
            <span class="n">chunk_shape</span> <span class="o">=</span> <span class="n">grid_shape</span>

        <span class="c1"># ensure that the chunk shape is a valid DomainDimensions object.</span>
        <span class="n">chunk_shape</span> <span class="o">=</span> <span class="n">DomainDimensions</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">)</span>

        <span class="c1"># check that the dimensions are uniform.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">({</span><span class="n">bbox</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">),</span> <span class="n">coordinates_ndim</span><span class="p">})</span>
            <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Detected inconsistent dimensions while building skeleton: dimensions for bbox, grid_shape,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; chunk_shape, and coordinate system were&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="p">[</span><span class="n">bbox</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">),</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">),</span><span class="w"> </span><span class="n">coordinates_ndim</span><span class="p">]</span><span class="si">}</span><span class="s2"> respectively.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check that the grid shape can be divided by the chunk shape.</span>
        <span class="c1"># This ensures that we don&#39;t get any partial chunks.</span>
        <span class="c1"># Check that the chunks fit</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">grid_shape</span> <span class="o">%</span> <span class="n">chunk_shape</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Grid shape </span><span class="si">{</span><span class="n">grid_shape</span><span class="si">}</span><span class="s2"> must be divisible by chunk shape </span><span class="si">{</span><span class="n">chunk_shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; Pisces does not support partial chunking.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Coerce the scale to be a format that we like.</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The scale needs to be set to the default. We check for instance type to ensure</span>
            <span class="c1"># that we do not provide access to a mutable attribute of the class.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_SCALE</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_SCALE</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_SCALE</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Alter the scale to be an iterable of the correct length.</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span><span class="p">]</span> <span class="o">*</span> <span class="n">coordinate_system</span><span class="o">.</span><span class="n">NDIM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">!=</span> <span class="n">coordinate_system</span><span class="o">.</span><span class="n">NDIM</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Scale </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2"> must be specified for all dimensions.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">scale</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Scale </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2"> must be linear or log.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the length unit.</span>
        <span class="k">if</span> <span class="n">length_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length_unit</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_LENGTH_UNIT</span>

        <span class="c1"># Setup the attributes and construct the structure.</span>
        <span class="c1"># All validation tasks are complete, we can now proceed with the generation of</span>
        <span class="c1"># the structure.</span>
        <span class="c1">#</span>
        <span class="c1"># Add the coordinate system to the file at the CSYS group position.</span>
        <span class="n">coordinate_system</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">handle</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;CSYS&quot;</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;hdf5&quot;</span><span class="p">)</span>

        <span class="c1"># WRITE parameters to disk</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LUNIT&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">length_unit</span><span class="p">)</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;SCALE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;CHUNK_SHAPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk_shape</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;BBOX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;GRID_SHAPE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_shape</span>

        <span class="k">return</span> <span class="n">handle</span></div>


    <span class="c1"># @@ DUNDER METHODS @@ #</span>
    <span class="c1"># These are basic dunder methods. They should not be</span>
    <span class="c1"># altered in subclasses to preserve base-level functionality</span>
    <span class="c1"># across subclass structures.</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ModelField&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of fields.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a field exists in the grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all fields in the grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">)</span>

    <span class="c1"># @@ COORDINATE MANAGEMENT @@ #</span>
    <span class="c1"># These methods are used for coordinate determinations.</span>
    <span class="k">def</span> <span class="nf">_get_coordinate_parameters</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stencil_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_complex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute coordinate parameters for generating grids.</span>

<span class="sd">        This function calculates the coordinate ranges and resolutions required for generating</span>
<span class="sd">        grids using either meshgrid or linspace. It can account for chunks and stencil regions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes_mask : np.ndarray[bool]</span>
<span class="sd">            A boolean mask specifying the axes for which coordinates are computed.</span>
<span class="sd">        chunk_index : :py:class:`~pisces.models.grids.structs.ChunkIndex`, optional</span>
<span class="sd">            The index of the chunk for which coordinates are computed. If `None`, compute for the entire grid.</span>
<span class="sd">        stencil_kwargs : dict, optional</span>
<span class="sd">            Parameters for defining a stencil around the chunk. Should include:</span>
<span class="sd">            - `stencil_size` (int): Size of the stencil (in chunks).</span>
<span class="sd">            - `stencil_alignment` (str): Alignment of the stencil (`&#39;center&#39;`, `&#39;left&#39;`, or `&#39;right&#39;`).</span>
<span class="sd">            Default is `{&#39;stencil_size&#39;: 1, &#39;stencil_alignment&#39;: &#39;center&#39;}`.</span>
<span class="sd">        use_complex : bool, optional</span>
<span class="sd">            If `True`, slices will use complex numbers for the step, which is compatible with `np.mgrid`.</span>
<span class="sd">            If `False`, slices will use integer steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of tuples</span>
<span class="sd">            A list of tuples for each axis in the `axes_mask`, where each tuple contains:</span>
<span class="sd">            - Start coordinate.</span>
<span class="sd">            - End coordinate.</span>
<span class="sd">            - Number of points (complex if `use_complex=True`).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes, chunk indices, or stencil parameters are provided.</span>
<span class="sd">        Warning</span>
<span class="sd">            If `stencil_kwargs` are provided without a `chunk_index`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If `chunk_index` is provided, the bounding box and shape are determined for the chunk or stencil.</span>
<span class="sd">        - If `stencil_kwargs` are not provided, defaults are used when `chunk_index` is specified.</span>
<span class="sd">        - The bounding box is always scaled to ensure uniform spacing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="c1"># Validate stencil and chunk arguments. If we have a ``chunk_index`` and no ``stencil_kwargs``, we need</span>
        <span class="c1"># to set the default stencil kwargs. Otherwise, we need to raise a warning if ``chunk_index`` is not specified</span>
        <span class="c1"># and the stencil is because we don&#39;t use the stencil unless there is a specified chunk.</span>
        <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stencil_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Stencil kwargs provided without a chunk index. This is redundant and will be ignored.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stencil_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stencil_kwargs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">{}</span>
            <span class="p">)</span>  <span class="c1"># All these functions use kwargs with built-in defaults.</span>

        <span class="c1"># Determine bounding box and shape</span>
        <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">stencil_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stencil_size&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Fails by default.</span>
                <span class="c1"># We have a stencil that is larger than a single chunk. We can then proceed.</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stencil_bbox</span><span class="p">(</span>
                    <span class="n">chunk_index</span><span class="o">=</span><span class="n">chunk_index</span><span class="p">,</span>
                    <span class="n">axes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="p">)[</span><span class="n">axes_mask</span><span class="p">]),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">stencil_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chunk_bbox</span><span class="p">(</span>
                    <span class="n">chunk_index</span><span class="o">=</span><span class="n">chunk_index</span><span class="p">,</span>
                    <span class="n">axes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="p">)[</span><span class="n">axes_mask</span><span class="p">]),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SCALED_BBOX</span><span class="p">[:,</span> <span class="n">axes_mask</span><span class="p">]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GRID_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

        <span class="c1"># Get cell size for each axis</span>
        <span class="n">cell_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CELL_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

        <span class="c1"># Generate coordinate slices</span>
        <span class="k">def</span> <span class="nf">slice_constructor</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cell_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="k">if</span> <span class="n">use_complex</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">points</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">slice_constructor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axes_mask</span><span class="p">))]</span>

<div class="viewcode-block" id="ModelGridManager.get_coordinates">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_coordinates.html#pisces.models.grids.base.ModelGridManager.get_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxesSpecifier</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stencil_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scaled</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the cell-centered coordinates for the grid or a specific chunk.</span>

<span class="sd">        This method generates the coordinates for the grid cells, either for the entire grid or a specific chunk,</span>
<span class="sd">        depending on the `chunk_index` parameter. The coordinates are computed based on the grid&#39;s bounding box,</span>
<span class="sd">        grid shape, and scaling (linear or logarithmic) configuration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index : :py:class:`~pisces.models.grids.structs.ChunkIndex`, optional</span>
<span class="sd">            The index of the chunk for which coordinates are computed. If `None`, the coordinates are computed</span>
<span class="sd">            for the entire grid.</span>
<span class="sd">        axes : Optional[AxesSpecifier], optional</span>
<span class="sd">            The axes for which coordinates are computed. If `None`, coordinates are computed for all axes defined</span>
<span class="sd">            by the grid&#39;s coordinate system.</span>
<span class="sd">        scaled : bool, optional</span>
<span class="sd">            If `True`, the coordinates are returned in their scaled (logarithmic) form for axes that are</span>
<span class="sd">            logarithmically scaled. This means the values for logarithmic axes will remain in their base-10</span>
<span class="sd">            logarithmic representation, preserving rectilinearity of the grid structure.</span>

<span class="sd">            If `False` (default), the coordinates for logarithmic axes are transformed back into linear space</span>
<span class="sd">            using a base-10 exponential transformation.</span>
<span class="sd">        stencil_kwargs : Optional[dict], optional</span>
<span class="sd">                Parameters defining a stencil region around the chunk. Should include:</span>

<span class="sd">                - `stencil_size` (int): Size of the stencil in chunks to include around the specified chunk. Default is 0.</span>
<span class="sd">                - `stencil_alignment` (str): Alignment of the stencil relative to the chunk, with options:</span>

<span class="sd">                    - `&#39;center&#39;`: Stencil is symmetrically centered around the chunk.</span>
<span class="sd">                    - `&#39;left&#39;`: Stencil extends entirely to the right of the chunk (default).</span>
<span class="sd">                    - `&#39;right&#39;`: Stencil extends entirely to the left of the chunk.</span>

<span class="sd">                If `chunk_index` is not provided, `stencil_kwargs` are ignored. If `chunk_index` is specified but</span>
<span class="sd">                `stencil_kwargs` is `None`, a default stencil of size 1 (centered) is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray[np.float64]</span>
<span class="sd">            An array of cell-centered coordinates with shape ``(*GRID_SHAPE, len(axes))`` (if `chunk_index` is `None`)</span>
<span class="sd">            or ``(*CHUNK_SHAPE, len(axes))`` (if `chunk_index` is specified). Each entry represents the center of</span>
<span class="sd">            a grid cell in the requested coordinate system.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes or chunk indices are provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validation. Ensure that we have a set of axes. Construct the axes mask.</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Obtain the slice data for the meshgrid. This performs all the</span>
        <span class="c1"># necessary validation and handles chunks vs. full grid.</span>
        <span class="c1"># NOTE: The reason we do this is because we might want just the slice</span>
        <span class="c1">#   data for other reasons in other methods.</span>
        <span class="n">slice_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coordinate_parameters</span><span class="p">(</span>
            <span class="n">axes_mask</span><span class="p">,</span>
            <span class="n">chunk_index</span><span class="o">=</span><span class="n">chunk_index</span><span class="p">,</span>
            <span class="n">stencil_kwargs</span><span class="o">=</span><span class="n">stencil_kwargs</span><span class="p">,</span>
            <span class="n">use_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">slice_data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">slc_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">slc_data</span> <span class="ow">in</span> <span class="n">slice_data</span><span class="p">]</span>

        <span class="c1"># Create the coordinate grid. This requires moving the axis to the</span>
        <span class="c1"># correct position and then rescaling for the log components.</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">*</span><span class="n">slice_data</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scaled</span><span class="p">:</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">10</span> <span class="o">**</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">coordinates</span></div>


    <span class="c1"># @@ INTERPOLATION @@ #</span>
    <span class="c1"># These methods are focused on robust interpolation of the fields in the</span>
    <span class="c1"># FIELDS attribute container.</span>
<div class="viewcode-block" id="ModelGridManager.build_field_interpolator">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.build_field_interpolator.html#pisces.models.grids.base.ModelGridManager.build_field_interpolator">[docs]</a>
    <span class="k">def</span> <span class="nf">build_field_interpolator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stencil_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an interpolator for a specified field.</span>

<span class="sd">        This method creates a ``RegularGridInterpolator`` for a given field, enabling interpolation</span>
<span class="sd">        of the field values over a rectilinear grid defined by the field&#39;s coordinate system. The</span>
<span class="sd">        interpolator can be cached for repeated use, and caching behavior can be customized.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_name : str</span>
<span class="sd">            The name of the field for which to build the interpolator.</span>
<span class="sd">        chunk_index : Optional[Any], optional</span>
<span class="sd">            The index of the chunk for which to build the interpolator. If ``None``, the interpolator</span>
<span class="sd">            is built for the entire grid.</span>
<span class="sd">        stencil_kwargs : Dict[str, Any], optional</span>
<span class="sd">            Arguments for generating a stencil around a specific chunk. These arguments define</span>
<span class="sd">            the size and alignment of the stencil. Only relevant if ``chunk_index`` is specified.</span>
<span class="sd">        cache : bool, optional</span>
<span class="sd">            Whether to cache the interpolator for future use. Default is ``True``.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If ``True``, any existing cached interpolator for the specified field and chunk is replaced.</span>
<span class="sd">            Default is ``False``.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments passed to the ``RegularGridInterpolator``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RegularGridInterpolator</span>
<span class="sd">            An interpolator object for the specified field.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the specified field does not exist in the grid manager.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The interpolator is built over a scaled (linearly spaced) grid to ensure rectilinear behavior.</span>
<span class="sd">        - If ``chunk_index`` is provided, the interpolator is built for the specified chunk or stencil</span>
<span class="sd">          region. Otherwise, it is built for the entire grid.</span>
<span class="sd">        - If ``cache`` is ``True``, the interpolator is stored in an internal cache for reuse. The cache</span>
<span class="sd">          key is a tuple of ``(field_name, chunk_index)``. To avoid cache conflicts, use ``overwrite=True``</span>
<span class="sd">          when necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that the field exists -- if not, raise error indicating.</span>
        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2"> is not defined.&quot;</span><span class="p">)</span>

        <span class="c1"># Retrieve the field reference and its associated axes</span>
        <span class="n">field_reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">field_reference</span><span class="o">.</span><span class="n">AXES</span><span class="p">)</span>

        <span class="c1"># Before proceeding with any other aspect of the procedure, check the cache</span>
        <span class="c1"># for an existing interpolator. If we find an interpolator in the cache,</span>
        <span class="c1"># we should simply pass it back immediately.</span>
        <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>
            <span class="n">_chunk_cache_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_chunk_cache_key</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>

        <span class="k">if</span> <span class="n">cache</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">_chunk_cache_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>

        <span class="c1"># Manage the chunking initialization. If we have a chunk index, we need</span>
        <span class="c1"># to validate it and then determine the chunking mask within the relevant stencil</span>
        <span class="c1"># around the specified chunk.</span>
        <span class="c1">#</span>
        <span class="c1"># Additionally: we want a baseline stencil no-matter-what for interpolation, so</span>
        <span class="c1"># the default stencil kwargs need to be constructed.</span>
        <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>

            <span class="c1"># Fix up the stencil kwargs to ensure that we have a stencil</span>
            <span class="k">if</span> <span class="n">stencil_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stencil_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stencil_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stencil_alignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>

            <span class="n">coordinate_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coordinate_parameters</span><span class="p">(</span>
                <span class="n">axes_mask</span><span class="p">,</span>
                <span class="n">use_complex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">chunk_index</span><span class="o">=</span><span class="n">chunk_index</span><span class="p">,</span>
                <span class="n">stencil_kwargs</span><span class="o">=</span><span class="n">stencil_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fetch the full grid coordinate parameters</span>
            <span class="n">coordinate_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coordinate_parameters</span><span class="p">(</span>
                <span class="n">axes_mask</span><span class="p">,</span> <span class="n">use_complex</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="c1"># Construct the interpolation points via the list of linspaces generated</span>
        <span class="c1"># from the coordinate parameters obtained. Additionally, load the field data.</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">cparams</span><span class="p">)</span> <span class="k">for</span> <span class="n">cparams</span> <span class="ow">in</span> <span class="n">coordinate_parameters</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">field_reference</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">d</span>

        <span class="c1"># Construct and return the interpolator</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="c1"># Add the interpolator to the cache.</span>
            <span class="k">if</span> <span class="n">chunk_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_chunk_cache_key</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_chunk_cache_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">)</span>
            <span class="n">chunk_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">_chunk_cache_key</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_cache</span><span class="p">[</span><span class="n">chunk_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># @@ CHUNK UTILITIES @@ #</span>
    <span class="c1"># These methods are utilities for performing operations in</span>
    <span class="c1"># chunks.</span>
<div class="viewcode-block" id="ModelGridManager.get_chunk_bbox">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_chunk_bbox.html#pisces.models.grids.base.ModelGridManager.get_chunk_bbox">[docs]</a>
    <span class="k">def</span> <span class="nf">get_chunk_bbox</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundingBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the bounding box for a specific.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index: np.ndarray</span>
<span class="sd">            The index of the chunk. Should be an iterable of length ``NDIM`` with the index of</span>
<span class="sd">            the chunk along each axis.</span>
<span class="sd">        axes: Optional[List[str]], optional</span>
<span class="sd">            The axes along which the ``chunk_index`` is specified. By default, we assume a complete chunk index.</span>
<span class="sd">        scale: bool, optional</span>
<span class="sd">            If ``True``, will return the scaled bounding box section (see :py:attr:`SCALED_BBOX`). Otherwise, will</span>
<span class="sd">            return the standard bbox.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoundingBox</span>
<span class="sd">            The bounding box of the chunk in scaled coordinates.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes or chunk indices are provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate the axes.</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="c1"># Ensure the chunk index is valid.</span>
        <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>

        <span class="c1"># Pull out the positions. This is taken from the scaled bounding box because</span>
        <span class="c1"># the chunks have linear sizes in the scaled domain.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes_mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">chunk_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

        <span class="c1"># Build the base of the bbox.</span>
        <span class="n">_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Account for scaling</span>
        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">_bbox</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">10</span> <span class="o">**</span> <span class="n">_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">_bbox</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGridManager.get_chunk_mask">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_chunk_mask.html#pisces.models.grids.base.ModelGridManager.get_chunk_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_chunk_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">chunk_index</span><span class="p">:</span> <span class="n">ChunkIndex</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxesSpecifier</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the mask of the full grid corresponding to a specific ``chunk_index``.</span>

<span class="sd">        Given a set of ``axes``, the total grid has some shape ``(N_0,...,N_k)``. A chunk occupies some subset</span>
<span class="sd">        of that grid space. This function produces a list of slices to select only the relevant section corresponding</span>
<span class="sd">        to the desired chunk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index : ChunkIndex</span>
<span class="sd">            The index of the chunk.</span>
<span class="sd">        axes : AxesSpecifier</span>
<span class="sd">            The axes for which the slice indices are computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of slice</span>
<span class="sd">            The set of slices corresponding to the ``chunk_index``. Each element of the returned list corresponds</span>
<span class="sd">            to the corresponding slice in the grid along the specific axis specified in ``axes``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes or chunk indices are provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunk_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_stencil_start_end</span><span class="p">(</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">stencil_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">stencil_alignment</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the start and end indices for a stencil region around a specific chunk index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index : np.ndarray</span>
<span class="sd">            An array of chunk indices specifying the chunk&#39;s location along each axis.</span>
<span class="sd">        stencil_size : int</span>
<span class="sd">            The size of the stencil, expressed in the number of chunks to include around the chunk index.</span>
<span class="sd">        stencil_alignment : str</span>
<span class="sd">            Specifies how the stencil is aligned with the chunk. Options are:</span>
<span class="sd">            - &#39;center&#39;: The stencil extends symmetrically around the chunk (default).</span>
<span class="sd">            - &#39;left&#39;: The stencil extends entirely to the right of the chunk.</span>
<span class="sd">            - &#39;right&#39;: The stencil extends entirely to the left of the chunk.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray]</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - id_min: The start indices for the stencil region along each axis.</span>
<span class="sd">            - id_max: The end indices for the stencil region along each axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `stencil_alignment` is invalid or unsupported.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The indices returned are inclusive for `id_min` and exclusive for `id_max`.</span>
<span class="sd">        - The function ensures that the alignment rules are consistent with the specified `stencil_alignment`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute stencil boundaries based on alignment</span>
        <span class="k">if</span> <span class="n">stencil_alignment</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
            <span class="n">id_min</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">-</span> <span class="n">stencil_size</span>
            <span class="n">id_max</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">stencil_size</span>
        <span class="k">elif</span> <span class="n">stencil_alignment</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
            <span class="n">id_min</span> <span class="o">=</span> <span class="n">chunk_index</span>
            <span class="n">id_max</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stencil_size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">stencil_alignment</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
            <span class="n">id_min</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stencil_size</span><span class="p">)</span>
            <span class="n">id_max</span> <span class="o">=</span> <span class="n">chunk_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid stencil_alignment: </span><span class="si">{</span><span class="n">stencil_alignment</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected one of &#39;center&#39;, &#39;left&#39;, or &#39;right&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">id_min</span><span class="p">,</span> <span class="n">id_max</span>

<div class="viewcode-block" id="ModelGridManager.get_chunk_stencil">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_chunk_stencil.html#pisces.models.grids.base.ModelGridManager.get_chunk_stencil">[docs]</a>
    <span class="k">def</span> <span class="nf">get_chunk_stencil</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">ChunkIndex</span><span class="p">,</span>
        <span class="n">stencil_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">stencil_alignment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AxesSpecifier</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the mask of the grid corresponding to a stencil around a specific ``chunk_index``.</span>

<span class="sd">        This function generates slices for selecting a region of the grid that includes a stencil around a specific chunk.</span>
<span class="sd">        The stencil size and alignment can be specified to control the region of interest.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index : ChunkIndex</span>
<span class="sd">            The index of the chunk for which the stencil is computed.</span>
<span class="sd">        stencil_size : int, optional</span>
<span class="sd">            The size of the stencil (in cells) to include around the chunk. This applies symmetrically unless specified otherwise.</span>
<span class="sd">            By default, ``stencil_size`` is set to 1.</span>
<span class="sd">        stencil_alignment : str, optional</span>

<span class="sd">            Determines the alignment of the stencil relative to the chunk. Options are:</span>
<span class="sd">            - ``&#39;center&#39;``: Stencil extends symmetrically around the chunk (default).</span>
<span class="sd">            - ``&#39;before&#39;``: Stencil is offset before the chunk.</span>
<span class="sd">            - ``&#39;after&#39;``: Stencil is offset after the chunk.</span>

<span class="sd">        axes : Optional[AxesSpecifier], optional</span>
<span class="sd">            The axes for which the stencil slices are computed. Defaults to all axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of slice</span>
<span class="sd">            A list of slices defining the stencil region. Each slice corresponds to the specified axis</span>
<span class="sd">            and selects the region in the grid for the stencil.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes, chunk indices, or stencil alignment is provided.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the calculated stencil boundaries exceed the grid dimensions.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The stencil is defined in terms of the chunk boundaries and extended by the stencil size.</span>
<span class="sd">        - The function accounts for the grid&#39;s total dimensions to prevent out-of-bounds indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct a generic axes mask from the provided axes and generate</span>
        <span class="c1"># the chunk index from ChunkIndex using the chunk boundaries.</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>

        <span class="c1"># Construct the id min and id max for the stencils</span>
        <span class="n">id_min</span><span class="p">,</span> <span class="n">id_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stencil_start_end</span><span class="p">(</span>
            <span class="n">chunk_index</span><span class="p">,</span> <span class="n">stencil_size</span><span class="p">,</span> <span class="n">stencil_alignment</span>
        <span class="p">)</span>

        <span class="c1"># Construct the stencil start and end points based on the</span>
        <span class="c1"># chunk shapes.</span>
        <span class="n">stencil_start</span><span class="p">,</span> <span class="n">stencil_end</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">id_min</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">],</span>
            <span class="n">id_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stencil_start</span><span class="p">,</span> <span class="n">stencil_end</span><span class="p">)]</span></div>


<div class="viewcode-block" id="ModelGridManager.get_stencil_bbox">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_stencil_bbox.html#pisces.models.grids.base.ModelGridManager.get_stencil_bbox">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stencil_bbox</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">stencil_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">stencil_alignment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundingBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the bounding box for a stencil region around a specific chunk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chunk_index: np.ndarray</span>
<span class="sd">            The index of the chunk. Should be an iterable of length ``NDIM`` with the index of</span>
<span class="sd">            the chunk along each axis.</span>
<span class="sd">        stencil_size : int, optional</span>
<span class="sd">            The size of the stencil (in cells) to include around the chunk. This applies symmetrically unless specified otherwise.</span>
<span class="sd">            Default is 1. See ``stencil_alignment`` for details on how the stencil size affects the behavior.</span>
<span class="sd">        stencil_alignment : str, optional</span>

<span class="sd">            Determines the alignment of the stencil relative to the chunk. Options are:</span>
<span class="sd">            - ``&#39;center&#39;``: Stencil extends symmetrically around the chunk (default).</span>
<span class="sd">            - ``&#39;before&#39;``: Stencil is offset before the chunk.</span>
<span class="sd">            - ``&#39;after&#39;``: Stencil is offset after the chunk.</span>
<span class="sd">        axes: Optional[List[str]], optional</span>
<span class="sd">            The axes along which the ``chunk_index`` and stencil are specified. By default, we assume a complete chunk index.</span>
<span class="sd">        scale: bool, optional</span>
<span class="sd">            If ``True``, will return the scaled bounding box section (see :py:attr:`SCALED_BBOX`). Otherwise, will</span>
<span class="sd">            return the standard bbox.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoundingBox</span>
<span class="sd">            The bounding box of the stencil region in scaled or physical coordinates.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid axes or chunk indices are provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate the axes, construct the axes mask, and then ensure that the chunk index is</span>
        <span class="c1"># valid.</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">ChunkIndex</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">])</span>

        <span class="c1"># Determine the left and right corners of the stencil chunk id range</span>
        <span class="n">id_min</span><span class="p">,</span> <span class="n">id_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stencil_start_end</span><span class="p">(</span>
            <span class="n">chunk_index</span><span class="p">,</span> <span class="n">stencil_size</span><span class="p">,</span> <span class="n">stencil_alignment</span>
        <span class="p">)</span>

        <span class="c1"># Pull out the positions for the stencil region and then build the bounding box</span>
        <span class="c1"># to return.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes_mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">id_min</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes_mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">id_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>
        <span class="n">_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Account for scaling and return.</span>
        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">_bbox</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">10</span> <span class="o">**</span> <span class="n">_bbox</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">_bbox</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGridManager.iterate_over_chunks">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.iterate_over_chunks.html#pisces.models.grids.base.ModelGridManager.iterate_over_chunks">[docs]</a>
    <span class="k">def</span> <span class="nf">iterate_over_chunks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ChunkIndex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all chunks along the specified axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : Optional[List[str]], optional</span>
<span class="sd">            The axes for which chunks are iterated. If `None`, use all axes.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        NDArray[np.int_]</span>
<span class="sd">            The chunk index for each iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Manipulate the axes and generate the axes mask.</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Construct the index arrays. np.indices generates array of shape (NDIM,*self.NCHUNKS) which can then</span>
        <span class="c1"># be collapsed to (NDIM, TOTAL_CHUNKS) to contain all of the chunk indices.</span>
        <span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>  <span class="c1"># (NDIM, *self.NCHUNKS)</span>
        <span class="n">index_array</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># (NDIM, TOTAL_CHUNKS)</span>
        <span class="n">index_array</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (TOTAL_CHUNKS,NDIM)</span>

        <span class="k">for</span> <span class="n">chunk_index</span> <span class="ow">in</span> <span class="n">index_array</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">chunk_index</span></div>


<div class="viewcode-block" id="ModelGridManager.get_chunk_map">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_chunk_map.html#pisces.models.grids.base.ModelGridManager.get_chunk_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_chunk_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">:</span> <span class="s2">&quot;CoordinateArray&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map a set of coordinates to the corresponding chunk indices in the grid and return the unique chunks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinate_array : CoordinateArray</span>
<span class="sd">            Array of coordinates to map to chunks. Must align with the grid&#39;s bounding box and scaled axes.</span>
<span class="sd">        axes : List[str], optional</span>
<span class="sd">            List of axes over which the mapping is computed. Defaults to all axes in the coordinate system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - np.ndarray: An array of chunk indices corresponding to the input coordinates.</span>
<span class="sd">            - List[tuple]: A list of unique chunk indices present in the chunk map.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any points in the coordinate array are outside the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use all axes if none are specified</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span>

        <span class="c1"># Build the axes mask and validate the coordinate array</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">coordinate_array</span> <span class="o">=</span> <span class="n">CoordinateArray</span><span class="p">(</span><span class="n">coordinate_array</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

        <span class="c1"># Convert coordinates to scaled coordinates for uniform chunking</span>
        <span class="n">scaled_bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SCALED_BBOX</span><span class="p">[:,</span> <span class="n">axes_mask</span><span class="p">]</span>  <span class="c1"># Shape: (2, len(axes))</span>
        <span class="n">is_log_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>

        <span class="c1"># Apply logarithmic scaling where necessary</span>
        <span class="n">coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">is_log_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
            <span class="n">coordinate_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">is_log_mask</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Shift the coordinates to align with the bounding box</span>
        <span class="n">coordinate_array</span> <span class="o">-=</span> <span class="n">scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Check for out-of-bounds coordinates</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">coordinate_array</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">coordinate_array</span> <span class="o">&gt;</span> <span class="n">scaled_bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">scaled_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid coordinate array: some points are outside of the grid.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Convert scaled coordinates to chunk indices</span>
        <span class="n">scaled_chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]</span>  <span class="c1"># Shape: (len(axes),)</span>
        <span class="n">chunk_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">coordinate_array</span><span class="p">,</span> <span class="n">scaled_chunk_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Generate the list of unique chunks</span>
        <span class="n">unique_chunks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunk_indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">chunk_indices</span><span class="p">,</span> <span class="n">unique_chunks</span></div>


    <span class="c1"># @@ UTILITY FUNCTIONS @@ #</span>
    <span class="c1"># These methods provide backend utilities for various processes</span>
    <span class="c1"># underlying chunk integration and operation management.</span>
<div class="viewcode-block" id="ModelGridManager.make_fields_consistent">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.make_fields_consistent.html#pisces.models.grids.base.ModelGridManager.make_fields_consistent">[docs]</a>
    <span class="k">def</span> <span class="nf">make_fields_consistent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">axes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures that multiple arrays are broadcastable based their axes.</span>

<span class="sd">        This function reshapes input arrays to ensure they are mutually broadcastable according to</span>
<span class="sd">        their respective axes and a shared coordinate system. It checks for consistency between</span>
<span class="sd">        the arrays, their associated axes, and the canonical axes defined in the coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arrays : list[NDArray[np.floating]]</span>
<span class="sd">            A list of arrays to reshape for broadcastability. Each array&#39;s shape must correspond to</span>
<span class="sd">            its specified axes.</span>
<span class="sd">        axes : list[list[str]]</span>
<span class="sd">            A list of axis specifications for each array. Each element is a list of axis names,</span>
<span class="sd">            indicating the dimensions along which the respective array varies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[NDArray[np.floating]]</span>
<span class="sd">            A list of reshaped arrays, all of which are mutually broadcastable based on the</span>
<span class="sd">            canonical axes of the coordinate system.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the lengths of ``arrays`` and ``axes`` do not match, if any axis in ``axes`` is not</span>
<span class="sd">            present in the canonical ``coordinate_system.AXES``, or if the arrays are not</span>
<span class="sd">            mutually broadcastable after reshaping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">make_grid_fields_broadcastable</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">coordinate_system</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span>
        <span class="p">)</span></div>


    <span class="c1"># @@ FEATURES @@ #</span>
<div class="viewcode-block" id="ModelGridManager.add_field_from_function">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.add_field_from_function.html#pisces.models.grids.base.ModelGridManager.add_field_from_function">[docs]</a>
    <span class="k">def</span> <span class="nf">add_field_from_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">chunking</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a :py:class:`ModelField` in this :py:class:`ModelGridManager` by evaluating the provided function.</span>

<span class="sd">        This method takes a function (``function``) and evaluates it at the relevant grid points to generate</span>
<span class="sd">        a new field with name ``field_name``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : Callable</span>
<span class="sd">            A function which takes (as input) ``N`` arguments ``(x_1,...,x_N)`` corresponding to the coordinate</span>
<span class="sd">            values of the ``N`` axes specified by the ``axes`` argument. If ``axes`` is not specified, then ``N=NDIM``, where</span>
<span class="sd">            ``NDIM`` is the number of dimensions in the coordinate system.</span>
<span class="sd">        field_name : str</span>
<span class="sd">            The name to give to the newly generated field.</span>

<span class="sd">            .. note::</span>

<span class="sd">                The ``field_name`` will be the location in the HDF5 file as well (``FIELDS/field_name``).</span>

<span class="sd">        axes : Optional[List[str]], optional</span>
<span class="sd">            The coordinate axes along which the function is to be evaluated. If ``axes`` is not provided, then</span>
<span class="sd">            it is assumed that the function operates on all the coordinates of the coordinate system.</span>

<span class="sd">            .. hint::</span>

<span class="sd">                Ensure that ``axes`` is self-consistent with the call signature of the ``function`` parameter.</span>

<span class="sd">        chunking : bool, optional</span>
<span class="sd">            If `True`, evaluate the function in chunks. Default is `False`.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                This is generally not necessary unless you cannot load the entire base grid into memory at once. This</span>
<span class="sd">                is particularly common if the function is operating in 3 or more dimensions, in which case even moderately</span>
<span class="sd">                resolved grids may take up significant memory.</span>

<span class="sd">        units : Optional[str], optional</span>
<span class="sd">            The units to give to the field. If ``units`` is not provided, then it is assumed that the field is</span>
<span class="sd">            dimensionless.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            The data type of the field. Default is &quot;f8&quot;.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If `True`, overwrite an existing field with the same name. Default is `False`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the function, axes, or other parameters are invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the base field (empty) in the FIELDS collection.</span>
        <span class="c1"># This ensures that we can proceed to populate the field within this method.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span>
            <span class="n">field_name</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create a reference to the _field object so that we don&#39;t have</span>
        <span class="c1"># to load the entire object into memory at once.</span>
        <span class="n">_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunking</span><span class="p">:</span>
            <span class="c1"># We can proceed without chunking and just set the entire field at once.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">_field</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are going to use chunks. We now need to iterate through each chunk.</span>
            <span class="n">_progress_bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;(Chunked) Building field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NCHUNKS</span><span class="p">[</span><span class="n">axes</span><span class="p">])),</span>
                <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">disable</span><span class="o">=</span><span class="n">pisces_params</span><span class="p">[</span><span class="s2">&quot;system.preferences.disable_progress_bars&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_over_chunks</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="n">_chunk_mask</span><span class="p">,</span> <span class="n">_chunk_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_chunk_mask</span><span class="p">(</span>
                    <span class="n">_ci</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span>
                <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">(</span><span class="n">chunk_index</span><span class="o">=</span><span class="n">_ci</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
                <span class="n">_field</span><span class="p">[</span><span class="o">*</span><span class="n">_chunk_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">_chunk_coordinates</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">_progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">_progress_bar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="ModelGridManager.add_field_from_profile">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.add_field_from_profile.html#pisces.models.grids.base.ModelGridManager.add_field_from_profile">[docs]</a>
    <span class="k">def</span> <span class="nf">add_field_from_profile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">profile</span><span class="p">:</span> <span class="s2">&quot;Profile&quot;</span><span class="p">,</span>
        <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">chunking</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a :py:class:`ModelField` in this :py:class:`ModelGridManager` by evaluating the provided profile.</span>

<span class="sd">        This method effectively wraps the :py:meth:`ModelGridManager.add_field_from_function` but utilizes the axes</span>
<span class="sd">        information from the profile to reduce the number of necessary inputs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        profile : :py:class:`~pisces.profiles.base.Profile`</span>
<span class="sd">            Any valid :py:class:`~pisces.profiles.base.Profile` instance.</span>

<span class="sd">            .. hint::</span>

<span class="sd">                To be a valid :py:class:`~pisces.profiles.base.Profile` instance, the profile must have the same</span>
<span class="sd">                axes as :py:attr:`coordinate_system` or have axes which are a subset of them.</span>

<span class="sd">        field_name : str</span>
<span class="sd">            The name to give to the newly generated field.</span>

<span class="sd">            .. note::</span>

<span class="sd">                The ``field_name`` will be the location in the HDF5 file as well (``FIELDS/field_name``).</span>

<span class="sd">        chunking : bool, optional</span>
<span class="sd">            If `True`, evaluate the function in chunks. Default is `False`.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                This is generally not necessary unless you cannot load the entire base grid into memory at once. This</span>
<span class="sd">                is particularly common if the function is operating in 3 or more dimensions, in which case even moderately</span>
<span class="sd">                resolved grids may take up significant memory.</span>

<span class="sd">        units : Optional[str], optional</span>
<span class="sd">            The units to give to the field. If ``units`` is not provided, then it is assumed that the field is</span>
<span class="sd">            dimensionless.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            The data type of the field. Default is &quot;f8&quot;.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If `True`, overwrite an existing field with the same name. Default is `False`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the function, axes, or other parameters are invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that the profile&#39;s axes align with the grid&#39;s coordinate system</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">profile</span><span class="o">.</span><span class="n">AXES</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Profile axes </span><span class="si">{</span><span class="n">profile</span><span class="o">.</span><span class="n">AXES</span><span class="si">}</span><span class="s2"> are incompatible with the grid&#39;s coordinate system axes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine field units</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">units</span>

        <span class="c1"># Validate unit compatibility</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">!=</span> <span class="n">profile</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv_factor</span> <span class="o">=</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">units</span><span class="p">)</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">units</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unit conversion error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conv_factor</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Delegate to `add_field_from_function`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_field_from_function</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="o">*</span><span class="n">coords</span><span class="p">:</span> <span class="n">profile</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span> <span class="o">*</span> <span class="n">conv_factor</span><span class="p">,</span>
            <span class="n">field_name</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">profile</span><span class="o">.</span><span class="n">AXES</span><span class="p">,</span>
            <span class="n">chunking</span><span class="o">=</span><span class="n">chunking</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ModelGridManager.get_grid_summary">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.get_grid_summary.html#pisces.models.grids.base.ModelGridManager.get_grid_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">get_grid_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a summary of the grid structure used in the model.</span>

<span class="sd">        This summary includes:</span>
<span class="sd">        - Axis Name</span>
<span class="sd">        - Minimum and Maximum values on each axis</span>
<span class="sd">        - Number of grid cells and chunks</span>
<span class="sd">        - Grid cell size and chunk size</span>
<span class="sd">        - Scaling type (linear or logarithmic)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[List[List[Any]], str]</span>
<span class="sd">            - If the ``tabulate`` library is installed, the summary is returned as a formatted table string.</span>
<span class="sd">            - If ``tabulate`` is not available, the summary is returned as a nested list of grid information.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The ``BBOX`` attribute provides the bounding box for the grid.</span>
<span class="sd">        - The ``GRID_SHAPE`` specifies the total number of grid cells along each axis.</span>
<span class="sd">        - The ``CHUNK_SHAPE`` determines how the grid is split into chunks.</span>
<span class="sd">        - The ``CELL_SIZE`` and ``CHUNK_SIZE`` attributes reflect the spatial size of each grid cell and chunk.</span>
<span class="sd">        - Scaling type is either ``log`` (logarithmic) or ``lin`` (linear). If the scale is ``log``, values are adjusted to base-10 representation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pisces.models.grids.base.ModelGridManager : Manages grid structure and provides access to grid metadata.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The output will look something like this when `tabulate` is installed:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            +------+---------+---------+-----+-----------+----------------+----------------+-------+</span>
<span class="sd">            | Axis | Min.    | Max.    |  N  | N Chunks  | Cell Size      | Chunk Size     | Scale |</span>
<span class="sd">            +------+---------+---------+-----+-----------+----------------+----------------+-------+</span>
<span class="sd">            |   r  | 1.00e+00| 1.00e+03| 100 |     10    | 1.00e+00 - lin | 1.00e+01 - lin | lin   |</span>
<span class="sd">            | theta| 0.00e+00| 3.14e+00|  50 |      5    | 6.28e-02 - lin | 3.14e-01 - lin | lin   |</span>
<span class="sd">            |  phi | 0.00e+00| 6.28e+00|  72 |      9    | 8.73e-02 - lin | 5.24e-01 - lin | lin   |</span>
<span class="sd">            +------+---------+---------+-----+-----------+----------------+----------------+-------+</span>


<span class="sd">        If `tabulate` is not installed, the method will return raw data:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            [</span>
<span class="sd">                [&quot;r&quot;, &quot;1.00e+00&quot;, &quot;1.00e+03&quot;, 100, 10, &quot;1.00e+00 - lin&quot;, &quot;1.00e+01 - lin&quot;, &quot;lin&quot;],</span>
<span class="sd">                [&quot;theta&quot;, &quot;0.00e+00&quot;, &quot;3.14e+00&quot;, 50, 5, &quot;6.28e-02 - lin&quot;, &quot;3.14e-01 - lin&quot;, &quot;lin&quot;],</span>
<span class="sd">                [&quot;phi&quot;, &quot;0.00e+00&quot;, &quot;6.28e+00&quot;, 72, 9, &quot;8.73e-02 - lin&quot;, &quot;5.24e-01 - lin&quot;, &quot;lin&quot;]</span>
<span class="sd">            ]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Import the tabulate method that we need to successfully run this.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

            <span class="n">_use_tabulate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">_use_tabulate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">tabulate</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># ! TRICK the IDE</span>

        <span class="n">axes_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">axi</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="p">):</span>
            <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BBOX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axi</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">BBOX</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">axi</span><span class="p">]</span>
            <span class="n">Ngrid</span><span class="p">,</span> <span class="n">Nchunk</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">GRID_SHAPE</span><span class="p">[</span><span class="n">axi</span><span class="p">],</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GRID_SHAPE</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SHAPE</span><span class="p">)[</span><span class="n">axi</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">Sgrid</span><span class="p">,</span> <span class="n">Schunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CELL_SIZE</span><span class="p">[</span><span class="n">axi</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHUNK_SIZE</span><span class="p">[</span><span class="n">axi</span><span class="p">]</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">axi</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">amin</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">amax</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">Sgrid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Sgrid</span><span class="p">),</span><span class="w"> </span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> - log&quot;</span>
                <span class="n">Schunk</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Schunk</span><span class="p">),</span><span class="w"> </span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> - log&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">amin</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">amax</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Sgrid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Sgrid</span><span class="p">),</span><span class="w"> </span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> - lin&quot;</span>
                <span class="n">Schunk</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Schunk</span><span class="p">),</span><span class="w"> </span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> - lin&quot;</span>
                <span class="p">)</span>

            <span class="n">axes_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">ax</span><span class="p">,</span>
                    <span class="n">amin</span><span class="p">,</span>
                    <span class="n">amax</span><span class="p">,</span>
                    <span class="n">Ngrid</span><span class="p">,</span>
                    <span class="n">Nchunk</span><span class="p">,</span>
                    <span class="n">Sgrid</span><span class="p">,</span>
                    <span class="n">Schunk</span><span class="p">,</span>
                    <span class="n">scale</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_use_tabulate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">axes_info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tabulate</span><span class="p">(</span>
                <span class="n">axes_info</span><span class="p">,</span>
                <span class="n">headers</span><span class="o">=</span><span class="p">[</span>
                    <span class="s2">&quot;Axis&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Min.&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Max.&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;N&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;N Chunks&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Cell Size&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Chunk Size&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Scale&quot;</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">tablefmt</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="ModelGridManager.generate_slice_image_array">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelGridManager.generate_slice_image_array.html#pisces.models.grids.base.ModelGridManager.generate_slice_image_array">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_slice_image_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">view_axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">extent</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">resolution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 2D slice image array for a given field.</span>

<span class="sd">        This method computes a slice of a field along a specified axis, interpolating the field</span>
<span class="sd">        values at grid points to produce a 2D image array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field_name : str</span>
<span class="sd">            The name of the field to generate the slice for.</span>
<span class="sd">        view_axis : str</span>
<span class="sd">            The axis along which the slice is taken. Must be one of the coordinate system&#39;s axes.</span>
<span class="sd">        extent : np.ndarray[np.floating]</span>
<span class="sd">            A ``(2, 2)`` array specifying the minimum and maximum bounds for the slice in the two</span>
<span class="sd">            dimensions perpendicular to ``view_axis``.</span>
<span class="sd">        resolution : np.ndarray[np.int_]</span>
<span class="sd">            A ``(2,)`` array specifying the resolution (number of pixels) along the two slice dimensions.</span>
<span class="sd">        position : Optional[float], optional</span>
<span class="sd">            The position along the ``view_axis`` at which the slice is taken. Defaults to ``0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            A 2D array representing the interpolated field values on the slice. The array shape</span>
<span class="sd">            matches the specified ``resolution``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the specified field does not exist or if the input parameters are invalid.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The method uses ``build_image_coordinate_array`` to construct a coordinate grid for the slice.</span>
<span class="sd">        - The grid is then transformed to match the field&#39;s coordinate system.</span>
<span class="sd">        - Logarithmic scaling is applied to coordinates where applicable.</span>
<span class="sd">        - A field interpolator is used to compute the field values on the slice grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that the field exists and pull the reference to the</span>
        <span class="c1"># field out of the FIELDS attribute.</span>
        <span class="k">if</span> <span class="n">field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot create image if field `</span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2">`: failed to find field in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">field_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FIELDS</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
        <span class="n">axes_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">field_ref</span><span class="o">.</span><span class="n">AXES</span><span class="p">)</span>

        <span class="c1"># Construct and convert the underlying coordinate grid. This will require generating the</span>
        <span class="c1"># coordinate grid for the slice and then converting it to the expected coordinate system.</span>
        <span class="n">image_coordinates</span> <span class="o">=</span> <span class="n">build_image_coordinate_array</span><span class="p">(</span>
            <span class="n">extent</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">view_axis</span><span class="p">,</span> <span class="n">position</span>
        <span class="p">)</span>
        <span class="n">image_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">image_coordinates</span><span class="p">)</span>

        <span class="c1"># Convert image coordinates so that they are log scaled where necessary</span>
        <span class="c1"># and cut down to the axes cut.</span>
        <span class="n">image_coordinates</span> <span class="o">=</span> <span class="n">image_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">axes_mask</span><span class="p">]</span>
        <span class="n">image_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
            <span class="n">image_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log_mask</span><span class="p">[</span><span class="n">axes_mask</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="n">image_shape</span> <span class="o">=</span> <span class="n">image_coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Perform the interpolation procedure to figure out what values the</span>
        <span class="c1"># field takes on the image coordinate grid.</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_field_interpolator</span><span class="p">(</span>
            <span class="n">field_name</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># Construct the image array by calling the interpolator.</span>
        <span class="c1"># The interpolator exists (N, NDIM) as input -&gt; we have (*RES, NDIM).</span>
        <span class="n">image_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_coordinates</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_ref</span><span class="o">.</span><span class="n">AXES</span><span class="p">)))</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interpolator</span><span class="p">(</span><span class="n">image_coordinates</span><span class="p">))</span>

        <span class="c1"># Reconstruct image shape</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>


    <span class="c1"># @@ PROPERTIES @@ #</span>
    <span class="c1"># For the most part, these all point to private</span>
    <span class="c1"># attributes elsewhere in the class structure. They shouldn&#39;t</span>
    <span class="c1"># need to be modified when generating a subclass.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">FIELDS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ModelFieldContainer&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The physical fields in this manager file.</span>

<span class="sd">        The :py:attr:`FIELDS` attribute exposes the :py:class:`ModelFieldContainer` component of the :py:class:`ModelGridManager`</span>
<span class="sd">        allowing easy access to the physical fields in this manager. Each field is effectively a numpy array containing the</span>
<span class="sd">        data parameterizing one of the profiles in the model on a particular set of axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`ModelFieldContainer`</span>
<span class="sd">            The container for managing the fields in the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Fields container has not been initialized. Ensure the grid manager is correctly initialized.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">BBOX</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundingBox</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The bounding box describing the limits of the physical grid. The ``BBOX`` for the manager is a ``(2,NDIM)``</span>
<span class="sd">        array containing the minimum and maximum values of the grid along each of the axes of the coordinate space.</span>

<span class="sd">        For specific :py:class:`ModelField` instances within the manager, only a subset of these grid axes are necessarily</span>
<span class="sd">        present; however, they will always fill the ``BBOX`` in their relevant dimensions.</span>

<span class="sd">        .. tip::</span>

<span class="sd">            Intuitively, the :py:attr:`BBOX` determines the entire domain, then specific fields may simply be slices</span>
<span class="sd">            through that domain.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`~pisces.models.grids.structs.BoundingBox`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BBOX</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">GRID_SHAPE</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DomainDimensions</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the full domain grid.</span>

<span class="sd">        The full grid shape determines how large field arrays will be in this :py:class:`ModelGridManager` instance.</span>
<span class="sd">        Each element of the grid shape corresponds to the number of cells in the grid along the axis matching that index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`~pisces.models.grids.structs.DomainDimensions`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GRID_SHAPE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CHUNK_SHAPE</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DomainDimensions</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The chunk shape of the grid.</span>

<span class="sd">        The chunk shape specifies the number of cells in each dimension which are present in any chunk of the domain. This</span>
<span class="sd">        parameter is a critical component of chunked-operations, which perform an operation on individual chunks to preserve</span>
<span class="sd">        memory.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            The :py:attr:`CHUNK_SHAPE` attribute is set when the manager is created. If it is small, then chunked operations</span>
<span class="sd">            will take longer, but will have a lower maximum memory usage. For large chunks, the opposite is true.</span>

<span class="sd">            By default, we have a single chunk and everything is done in one pass (assuming your system has sufficient memory).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`~pisces.models.grids.structs.DomainDimensions`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SHAPE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The scaling between cells along each grid axis.</span>

<span class="sd">        Each element in :py:attr:`scale` is either ``&quot;linear&quot;`` or ``&quot;log&quot;``, indicating the spacing between</span>
<span class="sd">        adjacent cells along the corresponding grid axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinate_system</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CoordinateSystem</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The coordinate system associated with this manager.</span>

<span class="sd">        The coordinate system determines the number of dimensions for the grid, the different available axes, and various</span>
<span class="sd">        other parameters for the manager. It also provides capabilities for rapid transformations of the grid domain.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`~pisces.models.grids.CoordinateSystem`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_system</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The unit of length corresponding to the grid domain.</span>

<span class="sd">        :py:class:`ModelGridManagers` store the underlying grid as unitless values; these units allow for</span>
<span class="sd">        the grid domain, cell spacing, etc. to be connect to physical quantities correctly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`unyt.Unit`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The path associated with this manager.</span>

<span class="sd">        This is the file path to the underlying HDF5 file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HDF5_File_Handle</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The HDF5 file handle associated with this manager.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`~pisces.io.hdf5.HDF5_File_Handle`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">NCHUNKS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DomainDimensions</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of chunks along each axis of the grid.</span>

<span class="sd">        Each entry corresponds to how many chunks are laid out along</span>
<span class="sd">        the associated axis, given the total :py:attr:`GRID_SHAPE` and :py:attr:`CHUNK_SHAPE`.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            If there :math:`N^i` cells along the :math:`i`-th dimension and chunks are :math:`n^i` in size, then</span>
<span class="sd">            the number of chunks is just</span>

<span class="sd">            .. math::</span>

<span class="sd">                N_{\rm chunks}^i = \frac{N^i}{n^i}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DomainDimensions</span>
<span class="sd">            A :py:class:`~pisces.models.grids.structs.DomainDimensions` object</span>
<span class="sd">            specifying how many chunks exist for each axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NCHUNKS</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CHUNK_SIZE</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The size of each chunk along every axis in scaled coordinates.</span>

<span class="sd">        This array has one entry per axis (like :py:attr:`GRID_SHAPE`), specifying</span>
<span class="sd">        how large each chunk is in the same scaling (log or linear) that</span>
<span class="sd">        the manager uses internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 1D array of length ``NDIM`` giving the chunk size for each axis,</span>
<span class="sd">            in scaled coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CELL_SIZE</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The size of each cell in scaled coordinates.</span>

<span class="sd">        Each cells size is determined by dividing :py:attr:`CHUNK_SIZE` by :py:attr:`CHUNK_SHAPE`.</span>
<span class="sd">        As such, this array has the same dimensionality as :py:attr:`CHUNK_SIZE`, giving</span>
<span class="sd">        the per-axis size for a single cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 1D array of length ``NDIM`` specifying each cells extent in scaled units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CELL_SIZE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">SCALED_BBOX</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The bounding box in scaled coordinates.</span>

<span class="sd">        Whereas :py:attr:`BBOX` corresponds to the physical boundaries of the domain, :py:attr:`SCALED_BBOX`</span>
<span class="sd">        transforms any logarithmic axes (see :py:attr:`scale`) to their base-10 value. In the :py:attr:`SCALED_BBOX`,</span>
<span class="sd">        grid spacing and positions are all uniform, even if they are logarithmically scaled in the physical space.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            This is most useful for developers; the idea is that you can streamline processes involving obtaining</span>
<span class="sd">            grid coordinates by &quot;standardizing&quot; coordinates and then just inverting the transformation at the end.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A ``(2, NDIM)`` array with the minimum and maximum scaled values</span>
<span class="sd">            of each axis in the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_bbox</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_log_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates which axes are scaled logarithmically.</span>

<span class="sd">        A boolean array of length ``NDIM``, where each element is ``True``</span>
<span class="sd">        if the corresponding axis in :py:attr:`scale` is set to ``&#39;log&#39;``,</span>
<span class="sd">        and `False` otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 1D boolean array with ``True`` entries for log-scaled axes,</span>
<span class="sd">            and `False` for linear-scaled axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_mask</span></div>



<div class="viewcode-block" id="ModelField">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelField.html#pisces.models.grids.base.ModelField">[docs]</a>
<span class="k">class</span> <span class="nc">ModelField</span><span class="p">(</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A field representing a physical profile in a :py:class:`ModelGridManager`.</span>

<span class="sd">    The :py:class:`ModelGridManager` acts as a collection of fields (:py:class:`ModelField`) along with a set of metadata</span>
<span class="sd">    including the relevant chunk, cell, and grid sizes; the coordinate system, etc. Each field in the manager represents</span>
<span class="sd">    a distinct physical profile over some set of dimensions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The :py:class:`ModelField` class derives from the :py:class:`unyt.unyt_array` class with only a minor tweak:</span>

<span class="sd">        Sections / slices of fields are dynamically loaded from an underlying HDF5 dataset.</span>

<span class="sd">    This means that, even for very large arrays, data can be read chunk-by-chunk or simply sliced into without having</span>
<span class="sd">    to load the entire array.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Generally speaking, this is done for you / in the backend of model generation routines. If you&#39;re developing a</span>
<span class="sd">        new model, this may be relevant to how you design your model. Most importantly, if your arrays are going to be</span>
<span class="sd">        large, take advantage of this architecture by operating in chunks instead of loading the entire array into</span>
<span class="sd">        memory at once.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">manager</span><span class="p">:</span> <span class="n">ModelGridManager</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Build or retrieve the underlying HDF5 dataset.</span>
        <span class="c1">#    This ensures shape/units are validated and sets the dataset attributes.</span>
        <span class="c1">#    If the manager already has the dataset in question, it just gets returned here</span>
        <span class="c1">#    otherwise, we generate a new skeleton.</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">build_skeleton</span><span class="p">(</span>
            <span class="n">manager</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">axes</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Extract final units and axis ordering from the dataset&#39;s attributes.</span>
        <span class="c1">#    These might differ from user inputs if the skeleton had to coerce them.</span>
        <span class="n">_units</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span>

        <span class="c1"># 3) Create the unyt array instance with placeholder data to avoid</span>
        <span class="c1">#    loading a large array into memory.</span>
        <span class="c1">#    We rely on on-disk slicing for actual data reads.</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">[],</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>

        <span class="c1"># 4) Attach references to the newly constructed object.</span>
        <span class="c1">#    - `buffer` points to the on-disk dataset.</span>
        <span class="c1">#    - `_axes` records which axes this field depends on.</span>
        <span class="c1">#    - `_manager` points to the grid manager.</span>
        <span class="c1">#    - `_geometry_handler` is a dynamic loading reference for the geometry handler.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">_units</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_manager</span> <span class="o">=</span> <span class="n">manager</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="n">_axes</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_geometry_handler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="c1"># noinspection PyUnusedLocal</span>
<div class="viewcode-block" id="ModelField.__init__">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelField.__init__.html#pisces.models.grids.base.ModelField.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">manager</span><span class="p">:</span> <span class="n">ModelGridManager</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new :py:class:`ModelField` instance, backed by an HDF5 dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : :py:class:`ModelGridManager`</span>
<span class="sd">            The grid manager that owns/coordinates this field structure.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                The ``manager`` provides the coordinate system, the HDF5 access, and other</span>
<span class="sd">                &quot;global&quot; properties for the field.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of this field. This is (or will become) the name of the dataset in the</span>
<span class="sd">            underlying HDF5 group.</span>
<span class="sd">        axes : list of str, optional</span>
<span class="sd">            The axes (from the underlying :py:class:`~pisces.geometry.base.CoordinateSystem`) that are</span>
<span class="sd">            present in this field.</span>

<span class="sd">            The axes are used to determine the shape of the dataset based on the ``manager``&#39;s</span>
<span class="sd">            grid shape, bounding box, and other attributes.</span>

<span class="sd">            .. note::</span>

<span class="sd">                ``axes`` are **always** reordered in the method to match the ordering native to the</span>
<span class="sd">                coordinate system for consistency.</span>

<span class="sd">        data : unyt.unyt_array or numpy.ndarray, optional</span>
<span class="sd">            Initial data to store in the newly generated dataset. This should be a ``(...,)`` array matching</span>
<span class="sd">            the expected shape of the grid determined from the ``manager``. If no data is provided, then the</span>
<span class="sd">            array is filled with nulls.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                The ``manager`` has the :py:attr:`ModelGridManager.GRID_SHAPE`, which specifies the expected</span>
<span class="sd">                shape for each axis. The ``data`` should then match the shape along each of the axes that</span>
<span class="sd">                are specified in ``axes``.</span>


<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, an existing field/dataset with this name is deleted and replaced. Defaults to False.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            The NumPy dtype to use for storing the data. Defaults to &#39;f8&#39;.</span>
<span class="sd">        units : str or unyt.Unit, optional</span>
<span class="sd">            Physical units of the field. If ``data`` is a unyt array with a</span>
<span class="sd">            different unit, an attempt is made to convert. Defaults to &#39;&#39; (unitless).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method calls :meth:`ModelField.build_skeleton` to either create or retrieve an</span>
<span class="sd">          existing dataset from the underlying HDF5 file.</span>
<span class="sd">        - The returned object is effectively a ``unyt.unyt_array`` but references</span>
<span class="sd">          an on-disk dataset for its storage. Slices can be read/written without</span>
<span class="sd">          loading the entire dataset into memory.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If data shape or units are incompatible with the manager&#39;s setup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ModelField.build_skeleton">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelField.build_skeleton.html#pisces.models.grids.base.ModelField.build_skeleton">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_skeleton</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">manager</span><span class="p">:</span> <span class="n">ModelGridManager</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new :py:class:`ModelField` structure (an HDF5 dataset).</span>

<span class="sd">        If ``name`` is already in the ``FIELDS`` group of the ``manager``, then the</span>
<span class="sd">        existing dataset structure is returned. If not, then the other arguments are</span>
<span class="sd">        used to generate a new field structure in the correct position.</span>

<span class="sd">        .. tip::</span>

<span class="sd">            If you want to overwrite an existing field, you should use ``overwrite=True``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : :py:class:`ModelGridManager`</span>
<span class="sd">            The grid manager that owns/coordinates this field structure.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                The ``manager`` provides the coordinate system, the HDF5 access, and other</span>
<span class="sd">                &quot;global&quot; properties for the field.</span>

<span class="sd">        name : str</span>
<span class="sd">            The name of this field. This is (or will become) the name of the dataset in the</span>
<span class="sd">            underlying HDF5 group.</span>
<span class="sd">        axes : list of str, optional</span>
<span class="sd">            The axes (from the underlying :py:class:`~pisces.geometry.base.CoordinateSystem`) that are</span>
<span class="sd">            present in this field.</span>

<span class="sd">            The axes are used to determine the shape of the dataset based on the ``manager``&#39;s</span>
<span class="sd">            grid shape, bounding box, and other attributes.</span>

<span class="sd">            .. note::</span>

<span class="sd">                ``axes`` are **always** reordered in the method to match the ordering native to the</span>
<span class="sd">                coordinate system for consistency.</span>

<span class="sd">        data : unyt.unyt_array or numpy.ndarray, optional</span>
<span class="sd">            Initial data to store in the newly generated dataset. This should be a ``(...,)`` array matching</span>
<span class="sd">            the expected shape of the grid determined from the ``manager``. If no data is provided, then the</span>
<span class="sd">            array is filled with nulls.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                The ``manager`` has the :py:attr:`ModelGridManager.GRID_SHAPE`, which specifies the expected</span>
<span class="sd">                shape for each axis. The ``data`` should then match the shape along each of the axes that</span>
<span class="sd">                are specified in ``axes``.</span>


<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, an existing field/dataset with this name is deleted and replaced. Defaults to False.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            The NumPy dtype to use for storing the data. Defaults to &#39;f8&#39;.</span>
<span class="sd">        units : str or unyt.Unit, optional</span>
<span class="sd">            Physical units of the field. If ``data`` is a unyt array with a</span>
<span class="sd">            different unit, an attempt is made to convert. Defaults to &#39;&#39; (unitless).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h5py.Dataset</span>
<span class="sd">            The dataset reference corresponding to the newly generated skeleton.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If data shape or units are incompatible with the manager&#39;s setup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Manage the HDF5 location / existence component of the procedure. If an</span>
        <span class="c1"># existing element is found a reference is checked against overwrite.</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span>
            <span class="s2">&quot;FIELDS&quot;</span>
        <span class="p">)</span>  <span class="c1"># This is the field storage location for all managers.</span>
        <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">devlog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;ModelField - build_skeleton: removing </span><span class="si">%s</span><span class="s2"> from </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">handle</span>
            <span class="p">)</span>
            <span class="k">del</span> <span class="n">handle</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># Look for (and return) an existing dataset of possible.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">handle</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">handle</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># @@ AXES MANAGEMENT @@ #</span>
        <span class="c1"># Discover the coordinate system and check axes and data shape to ensure compatibility.</span>
        <span class="c1"># Ensure that axes are ordered correctly before moving forward with the data onboarding.</span>
        <span class="n">_coordinate_system</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">coordinate_system</span>

        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># copy the axes from the coordinate system.</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">_coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_coordinate_system</span><span class="o">.</span><span class="n">AXES</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
            <span class="c1"># We have unrecognized axes.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The following axes are not recognized for the </span><span class="si">{</span><span class="n">_coordinate_system</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; coordinate system: </span><span class="si">{</span><span class="p">[</span><span class="n">ax</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ax</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">axes</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ax</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">_coordinate_system</span><span class="o">.</span><span class="n">AXES</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># ensure axes are in order</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">_coordinate_system</span><span class="o">.</span><span class="n">ensure_axis_order</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># @@ SHAPE COORDINATION @@ #</span>
        <span class="c1"># We need to determine the correct shape. If data was actually provided,</span>
        <span class="c1"># we need to check that it has the right shape to proceed.</span>
        <span class="n">axes_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_coordinate_system</span><span class="o">.</span><span class="n">ensure_axis_numeric</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>  <span class="c1"># Convert to indices.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">GRID_SHAPE</span><span class="p">[</span><span class="n">axes_indices</span><span class="p">]</span>

        <span class="c1"># @@ UNITS and DATA MANAGEMENT @@ #</span>
        <span class="c1"># This ensures that the units are handled correctly and that</span>
        <span class="c1"># we manage the data correctly as well.</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check the data for the correct shape.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to build ModelField skeleton:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (axes=</span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2">) but received shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># If there is data provided to us, we need to also validate</span>
            <span class="c1"># that the data is what we expect it to be in terms of units and type.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">):</span>
                <span class="n">data_units</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">units</span>
                <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Inconsistent units: provided data has units &#39;</span><span class="si">{</span><span class="n">data_units</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but specified units are &#39;</span><span class="si">{</span><span class="n">units</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">=</span> <span class="n">data_units</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">data_units</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># --&gt; set to default if not specified.</span>

            <span class="c1"># Enforce the datatype constraints.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># --&gt; set to default if not specified.</span>

        <span class="c1"># @@ DATASET CREATION @@ #</span>
        <span class="c1"># Create the relevant dataset and set the correct attributes.</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Set attributes</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span></div>


    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override numpy&#39;s ufunc behavior to ensure operations return a `unyt_array`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ufunc : numpy.ufunc</span>
<span class="sd">            The universal function to apply.</span>
<span class="sd">        method : str</span>
<span class="sd">            The ufunc method to use (e.g., &quot;__call__&quot;).</span>
<span class="sd">        *inputs : tuple</span>
<span class="sd">            Input arrays for the ufunc.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unyt_array</span>
<span class="sd">            The result of the operation with appropriate units.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Ensures unit consistency when performing numpy operations on `Field` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># CAST ANY ModelField TO unyt_array FOR THE OPERATION</span>
        <span class="c1"># (THIS AVOIDS LOADING ENTIRE ARRAYS; STILL SLICES ON DEMAND)</span>
        <span class="n">cast_inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ModelField</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">cast_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># ATTACH THIS FIELD&#39;S UNITS IF THE OPERATION YIELDS A unyt_array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">):</span>
            <span class="c1"># This is simplistic: e.g. for addition of different fields,</span>
            <span class="c1"># unyt already handles unit consistency in the operation itself.</span>
            <span class="c1"># But we can ensure the final unit is the same as `self.units` if</span>
            <span class="c1"># the operation is dimensionally consistent.</span>
            <span class="n">result</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a slice of the field&#39;s data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : slice or int</span>
<span class="sd">            The indices to set.</span>
<span class="sd">        value : unyt.unyt_array or numpy.ndarray</span>
<span class="sd">            The value(s) to set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the units of the value are incompatible with the field&#39;s units.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unit consistency is enforced when setting data. This ensures that</span>
<span class="sd">        the field&#39;s dataset always maintains valid physical units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Coerce units to ensure that we have</span>
        <span class="c1"># an unyt array to pass into the array.</span>
        <span class="c1"># Ensure that the units are self consistent.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`value` must be a unyt_array or numpy.ndarray, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed unit conversion: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="c1"># Write the data to the HDF5 dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a slice of data as a unyt_array with the field&#39;s units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GRAB THE RELEVANT PORTION DIRECTLY FROM DISK</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="c1"># =&gt; numpy ndarray</span>
        <span class="k">return</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinate_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut to this field&#39;s manager&#39;s coordinate system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manager</span><span class="o">.</span><span class="n">coordinate_system</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lazily instantiate and return a GeometryHandler for this field.</span>

<span class="sd">        A geometry handler can compute distances, angles, or other geometry-based</span>
<span class="sd">        transformations on the given axes. If not relevant to your use case,</span>
<span class="sd">        this may remain unused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_handler</span> <span class="o">=</span> <span class="n">GeometryHandler</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_system</span><span class="p">,</span> <span class="n">free_axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry_handler</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">AXES</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coordinate system axes over which this field is defined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List of str</span>
<span class="sd">            The axes names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">[:]</span>  <span class="c1"># Yield a copy, non-mutable.</span></div>



<div class="viewcode-block" id="ModelFieldContainer">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.html#pisces.models.grids.base.ModelFieldContainer">[docs]</a>
<span class="k">class</span> <span class="nc">ModelFieldContainer</span><span class="p">(</span><span class="n">HDF5ElementCache</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModelField</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container class that manages :py:class:`ModelField` objects within a shared HDF5 group.</span>

<span class="sd">    This class extends :py:class:`~pisces.io.HDF5ElementCache` to allow dictionary-like</span>
<span class="sd">    access to fields stored under ``manager.handle[&#39;FIELDS&#39;]``. Each field is keyed by</span>
<span class="sd">    a string (its name) and mapped to a :py:class:`ModelField` instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    manager : ModelGridManager</span>
<span class="sd">        The manager providing global grid info and the HDF5 file handle for storing fields.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Additional keyword arguments passed to :py:class:`~pisces.io.HDF5ElementCache`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The container ensures that when you retrieve or add a field, it is linked</span>
<span class="sd">      to the same underlying HDF5 group.</span>
<span class="sd">    - Fields can be referenced or created using dictionary syntax, e.g. ``my_container[&quot;density&quot;]``.</span>
<span class="sd">    - This class also provides convenience methods for copying or summarizing fields.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    HDF5ElementCache : Base caching mechanism for HDF5-backed collections.</span>
<span class="sd">    ModelField : Individual fields that store and retrieve array data from HDF5.</span>
<span class="sd">    ModelGridManager : Manages global metadata (axes, bounding box, chunking) for the grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelFieldContainer.__init__">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.__init__.html#pisces.models.grids.base.ModelFieldContainer.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">:</span> <span class="n">ModelGridManager</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ModelFieldContainer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : ModelGridManager</span>
<span class="sd">            The grid manager that owns this container, providing the</span>
<span class="sd">            relevant HDF5 handle and coordinate system info.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Passed directly to :py:class:`~pisces.io.HDF5ElementCache`</span>
<span class="sd">            for any specialized caching or I/O parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This __init__ simply generates a reference to the manager that got passed</span>
        <span class="c1"># through and then relies on the super class __init__ generate the structure.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_manager</span> <span class="o">=</span> <span class="n">manager</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_manager</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">require_group</span><span class="p">(</span><span class="s2">&quot;FIELDS&quot;</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_identify_elements_from_handle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="c1"># Method identifies which elements in the group are included. Its simple in</span>
        <span class="c1"># this case because all of the elements in the group are included.</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">elements</span>

    <span class="k">def</span> <span class="nf">_set_element_in_handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ModelField</span><span class="p">):</span>
        <span class="c1"># Sets a ``value`` in the underlying HDF5 space. Must check that</span>
        <span class="c1"># the ModelField we got passed is actually in the space. [Making this effectively redundant]</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ModelField&#39;s handle is not part of this container&#39;s handle.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add the Grid&#39;s handle to the container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_to_key</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">buffer</span>

    <span class="k">def</span> <span class="nf">_remove_element_from_handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_to_key</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_index_to_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_key_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span>

<div class="viewcode-block" id="ModelFieldContainer.load_element">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.load_element.html#pisces.models.grids.base.ModelFieldContainer.load_element">[docs]</a>
    <span class="k">def</span> <span class="nf">load_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ModelField</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a field by name (index) from the HDF5 group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : str</span>
<span class="sd">            The name of the field to load.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ModelField</span>
<span class="sd">            A newly created :py:class:`ModelField` object pointing to the dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This uses the :py:class:`ModelField` constructor. The field&#39;s shape,</span>
<span class="sd">          axes, and other attributes are taken from the on-disk HDF5 dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ModelField</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_manager</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelFieldContainer.copy_field">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.copy_field.html#pisces.models.grids.base.ModelFieldContainer.copy_field">[docs]</a>
    <span class="k">def</span> <span class="nf">copy_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">ModelField</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of an existing :py:class:`ModelField` under a new name in this container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : str</span>
<span class="sd">            The name (key) for the copied field in this container.</span>
<span class="sd">        field : ModelField</span>
<span class="sd">            The existing field to copy. Its underlying dataset is duplicated in HDF5.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, any existing field named ``index`` is removed first. Defaults to False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a field with the name ``index`` already exists and ``overwrite`` is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This uses HDF5&#39;s built-in ``.copy(...)`` function, which duplicates the entire</span>
<span class="sd">          dataset structure. This is potentially expensive for large data sets.</span>
<span class="sd">        - After copying, you can retrieve the new field with ``self[index]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_to_key</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Handle existing grid at the index</span>
        <span class="k">if</span> <span class="n">target_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A field already exists at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">. Use `overwrite=True` to replace it.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Remove the existing group</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">[</span><span class="n">target_key</span><span class="p">]</span>

        <span class="c1"># Use h5py&#39;s copy method to copy the entire structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">target_key</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelFieldContainer.add_field">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.add_field.html#pisces.models.grids.base.ModelFieldContainer.add_field">[docs]</a>
    <span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new :py:class:`ModelField` to the container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of this field. This is (or will become) the name of the dataset in the</span>
<span class="sd">            underlying HDF5 group.</span>
<span class="sd">        axes : list of str, optional</span>
<span class="sd">            The axes (from the underlying :py:class:`~pisces.geometry.base.CoordinateSystem`) that are</span>
<span class="sd">            present in this field.</span>

<span class="sd">            The axes are used to determine the shape of the dataset based on the ``manager``&#39;s</span>
<span class="sd">            grid shape, bounding box, and other attributes.</span>

<span class="sd">            .. note::</span>

<span class="sd">                ``axes`` are **always** reordered in the method to match the ordering native to the</span>
<span class="sd">                coordinate system for consistency.</span>

<span class="sd">        data : unyt.unyt_array or numpy.ndarray, optional</span>
<span class="sd">            Initial data to store in the newly generated dataset. This should be a ``(...,)`` array matching</span>
<span class="sd">            the expected shape of the grid determined from the ``manager``. If no data is provided, then the</span>
<span class="sd">            array is filled with nulls.</span>

<span class="sd">            .. tip::</span>

<span class="sd">                The ``manager`` has the :py:attr:`ModelGridManager.GRID_SHAPE`, which specifies the expected</span>
<span class="sd">                shape for each axis. The ``data`` should then match the shape along each of the axes that</span>
<span class="sd">                are specified in ``axes``.</span>


<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, an existing field/dataset with this name is deleted and replaced. Defaults to False.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            The NumPy dtype to use for storing the data. Defaults to &#39;f8&#39;.</span>
<span class="sd">        units : str or unyt.Unit, optional</span>
<span class="sd">            Physical units of the field. If ``data`` is a unyt array with a</span>
<span class="sd">            different unit, an attempt is made to convert. Defaults to &#39;&#39; (unitless).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`ModelField`</span>
<span class="sd">            The newly created :py:class:`ModelField` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">ModelField</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_manager</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">field</span></div>


<div class="viewcode-block" id="ModelFieldContainer.get_field_summary">
<a class="viewcode-back" href="../../../../_as_gen/pisces.models.grids.base.ModelFieldContainer.get_field_summary.html#pisces.models.grids.base.ModelFieldContainer.get_field_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">get_field_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a summary of all fields currently stored in the model.</span>

<span class="sd">        This summary includes:</span>

<span class="sd">        - Field name</span>
<span class="sd">        - Units of the field</span>
<span class="sd">        - Shape of the field data buffer</span>
<span class="sd">        - Axes over which the field is defined</span>
<span class="sd">        - Number of dimensions (ndim) of the field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[str, List[List[str]]]</span>
<span class="sd">            - If the `tabulate` library is installed, the summary is returned as a formatted table string.</span>
<span class="sd">            - If `tabulate` is not available, the summary is returned as a list of lists containing field metadata.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        - Fields are stored within the grid manager&#39;s `FIELDS` container.</span>
<span class="sd">        - Each field includes metadata such as its units, shape, and axes.</span>
<span class="sd">        - If `tabulate` is installed, a formatted grid table is returned for better readability.</span>
<span class="sd">        - If `tabulate` is unavailable, the raw summary data is returned for further processing.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If a field does not have the expected attributes like `units`, `buffer`, or `_axes`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pisces.models.grids.base.ModelFieldContainer : Container for storing and managing grid fields.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If `tabulate` is installed, the output will look like this:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            +-------------+--------+-------------+------------+-------+</span>
<span class="sd">            | Field Name  | Units  | Shape       | Axes       | Ndim  |</span>
<span class="sd">            +-------------+--------+-------------+------------+-------+</span>
<span class="sd">            | density     | g/cm^3 | (100, 50)   | [&#39;r&#39;, &#39;&#39;] |   2   |</span>
<span class="sd">            | temperature | K      | (100, 50)   | [&#39;r&#39;, &#39;&#39;] |   2   |</span>
<span class="sd">            | pressure    | Pa     | (100, 50)   | [&#39;r&#39;, &#39;&#39;] |   2   |</span>
<span class="sd">            +-------------+--------+-------------+------------+-------+</span>


<span class="sd">        If `tabulate` is not installed, the method will return the following:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            [</span>
<span class="sd">                [&#39;density&#39;, &#39;g/cm^3&#39;, &#39;(100, 50)&#39;, &quot;[&#39;r&#39;, &#39;&#39;]&quot;, &#39;2&#39;],</span>
<span class="sd">                [&#39;temperature&#39;, &#39;K&#39;, &#39;(100, 50)&#39;, &quot;[&#39;r&#39;, &#39;&#39;]&quot;, &#39;2&#39;],</span>
<span class="sd">                [&#39;pressure&#39;, &#39;Pa&#39;, &#39;(100, 50)&#39;, &quot;[&#39;r&#39;, &#39;&#39;]&quot;, &#39;2&#39;]</span>
<span class="sd">            ]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Import the tabulate method that we need to successfully run this.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

            <span class="n">_use_tabulate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">_use_tabulate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">tabulate</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># ! TRICK the IDE</span>

        <span class="c1"># Construct the field data</span>
        <span class="n">field_info</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">_fn</span><span class="p">,</span> <span class="n">_fv</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">_fv</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">_fv</span><span class="o">.</span><span class="n">AXES</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">_fv</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">_fn</span><span class="p">,</span> <span class="n">_fv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_use_tabulate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">field_info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tabulate</span><span class="p">(</span>
                <span class="n">field_info</span><span class="p">,</span>
                <span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Field Name&quot;</span><span class="p">,</span> <span class="s2">&quot;Units&quot;</span><span class="p">,</span> <span class="s2">&quot;Shape&quot;</span><span class="p">,</span> <span class="s2">&quot;Axes&quot;</span><span class="p">,</span> <span class="s2">&quot;Ndim&quot;</span><span class="p">],</span>
                <span class="n">tablefmt</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>